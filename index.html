<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simple RSA Key Pair Generator and Encrypt/Decrypt</title>
</head>

<body>

  <h1>Simple RSA Key Pair Generator and Encrypt/Decrypt</h1>

  <!-- Key Generation Section -->
  <section>
    <h2>Key Generation</h2>
    <label for="p">Enter prime number P:</label>
    <input type="text" id="p">
    <br>
    <label for="q">Enter prime number Q:</label>
    <input type="text" id="q">
    <br>
    <label for="n">Enter value of N (optional, leave empty to calculate):</label>
    <input type="text" id="n">
    <br>
    <button onclick="generateKeys()">Generate Keys</button>
  </section>

  <!-- Encryption Section -->
  <section>
    <h2>Encryption</h2>
    <label for="plaintext">Enter text to encrypt:</label>
    <input type="text" id="plaintextToEncrypt">
    <br>
    <button onclick="encrypt()">Encrypt</button>
    <p>Encrypted Text: <span id="encryptedText"></span></p>
  </section>

  <!-- Decryption Section -->
  <section>
    <h2>Decryption</h2>
    <label for="ciphertext">Enter text to decrypt:</label>
    <input type="text" id="ciphertextToDecrypt">
    <br>
    <button onclick="decrypt()">Decrypt</button>
    <p>Decrypted Text: <span id="decryptedText"></span></p>
  </section>

  <script>
    let publicKey, privateKey;

    function generateKeys() {
      const p = document.getElementById('p').value;
      const q = document.getElementById('q').value;
      let n = document.getElementById('n').value;

      if (!p || !q) {
        alert("Please enter values for both P and Q.");
        return;
      }

      n = n ? BigInt(n) : BigInt(p) * BigInt(q);

      const phi = (BigInt(p) - 1n) * (BigInt(q) - 1n);
      const e = BigInt(65537);  // Commonly used public exponent

      publicKey = { e, n };
      privateKey = modInverse(e, phi);

      alert('Keys generated successfully!');
    }

    function encrypt() {
      const plaintext = document.getElementById('plaintextToEncrypt').value;
      const encrypted = encryptText(plaintext, publicKey.e, publicKey.n);
      document.getElementById('encryptedText').textContent = encrypted;
    }

    function decrypt() {
      const ciphertext = document.getElementById('ciphertextToDecrypt').value;
      const decrypted = decryptText(ciphertext, privateKey, publicKey.n);
      document.getElementById('decryptedText').textContent = decrypted;
    }

    // Modular exponentiation for encryption
    function encryptText(plaintext, e, n) {
      let result = '';
      for (let i = 0; i < plaintext.length; i++) {
        const charCode = plaintext.charCodeAt(i);
        const encryptedCharCode = modPow(BigInt(charCode), e, n);
        result += encryptedCharCode.toString(16) + ' ';
      }
      return result.trim();
    }

    // Modular exponentiation for decryption
    function decryptText(ciphertext, d, n) {
      let result = '';
      const parts = ciphertext.split(' ');
      for (let i = 0; i < parts.length; i++) {
        const encryptedCharCode = BigInt('0x' + parts[i]);
        const decryptedCharCode = modPow(encryptedCharCode, d, n);
        result += String.fromCharCode(Number(decryptedCharCode));
      }
      return result;
    }


    // Modular exponentiation
    function modPow(base, exponent, modulus) {
      let result = BigInt(1);
      base = base % modulus;

      while (exponent > 0) {
        if (exponent % 2n === 1n) {
          result = (result * base) % modulus;
        }

        exponent = exponent >> 1n;
        base = (base * base) % modulus;
      }

      return result;
    }

    // Modular multiplicative inverse
    function modInverse(a, m) {
      const m0 = m;
      let x0 = 0n;
      let x1 = 1n;

      while (a > 1n) {
        const q = a / m;
        [a, m] = [m, a % m];
        [x0, x1] = [x1 - q * x0, x0];
      }

      return x1 < 0n ? x1 + m0 : x1;
    }
  </script>

</body>

</html>